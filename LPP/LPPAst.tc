%{ // cpp code
    #include <iostream>
    #include "LPPAst.hpp"

    // Create a vector from SymbolVector.
    SymbolVector vec;

	int offset = 4;

	int getOffset(){
		
		return offset;
	}

	int addOffset()
	{
		offset += 4;
	}

%}

%decls %{ // hpp code
    #include <string>
    #include <cmath>
    #include <unordered_map>
    #include "SemError.hpp"
    #include <vector>

    using stdstring = std::string;

    struct structElements {
        stdstring id;
        stdstring placeStack;
    };

    using SymbolVector = std::vector<structElements>;

%}

%option lang = "C++"


// NODOS.
%node AstNode %abstract %typedef = {
    %nocreate stdstring place;
    %nocreate stdstring code;
}

%node EmptyNode AstNode = {
}

// STATEMENT NODES.
%node Stmt AstNode %abstract

%node Program AstNode = {
    AstNode* stmts;
}

%node BlockStmt Stmt = {
    AstNode* stmt1;
    AstNode* stmt2;
}

%node InitialBlockStmt Stmt = {
    AstNode* stmt1;
    AstNode* stmt2;
    AstNode* stmt3;
}

%node AssignStmt Stmt = {
    AstNode *var;
    AstNode *rvalue;
}

%node PrintStmt Stmt = {
    AstNode *expr;
}

%node IfStmt Stmt = {
    AstNode *cond;
    AstNode *stmt_t;
    AstNode *stmt_f;
}

%node WhileStmt Stmt = {
    AstNode *cond;
    AstNode *stmt;
}

%node ForStmt Stmt = {
    AstNode *init;
    AstNode *cond;
    AstNode *inc;
    AstNode *stmt;
}

%node DecVarStmt Stmt = {
    AstNode *var1;
    AstNode *var2;
}

%node IntDecl AstNode = {
    AstNode* var1;
    AstNode* var2;
}


%node BinaryExpr AstNode %abstract = {
    AstNode *expr1;
    AstNode *expr2;
}


%node AddExpr BinaryExpr
%node SubExpr BinaryExpr
%node MultExpr BinaryExpr
%node NotEqualExpr BinaryExpr
%node EqualExpr BinaryExpr
%node LessOrEqualExpr BinaryExpr
%node LessExpr BinaryExpr          
%node GreaterOrEqualExpr BinaryExpr 
%node GreaterExpr BinaryExpr
%node AndExpr BinaryExpr
%node OrExpr BinaryExpr
%node ModExpr BinaryExpr
%node DivExpr BinaryExpr

%node NumExpr AstNode = {
    int value;
}

%node IdentExpr AstNode = {
    stdstring text;
}


// OPERACIONES.
%operation %virtual int evalSemantic(AstNode *this)
%operation %virtual stdstring genProgramCode(AstNode *this) 


// Evaluaci칩n de la sem치ntica.
evalSemantic(Program) {
    return {};
}

evalSemantic(AddExpr) {
    return {};
}

evalSemantic(SubExpr) {
    return {};
}

evalSemantic(MultExpr) {
    return {};
}

evalSemantic(EqualExpr) {
    return {};
}

evalSemantic(NotEqualExpr) {
    return {};
}

evalSemantic(LessOrEqualExpr) {
    return {};
}

evalSemantic(LessExpr) {
    return {};
}

evalSemantic(GreaterOrEqualExpr) {
    return {};
}

evalSemantic(GreaterExpr) {
    return {};
}

evalSemantic(AndExpr) {
    return {};
}

evalSemantic(OrExpr) {
    return {};
}

evalSemantic(ModExpr) {
    return {};
}


evalSemantic(DivExpr) {
    return {};
}

evalSemantic(NumExpr) {
    return {};
}

evalSemantic(IdentExpr) {
    return {};
}

evalSemantic(AssignStmt) {
    return {};
}

evalSemantic(PrintStmt) {
    return {};
}

evalSemantic(IfStmt) {
    return {};
}

evalSemantic(WhileStmt) {
    return {};
}

evalSemantic(ForStmt) {
    return {};
}

evalSemantic(BlockStmt) {
    return {};
}

evalSemantic(DecVarStmt){
    return {};
}

evalSemantic(IntDecl) {
    return {};
}

evalSemantic(InitialBlockStmt){
    return {};
}

// Generaci칩n de c칩digo

genProgramCode(InitialBlockStmt) {
    code += stmt1->genProgramCode();
    
    std::cout<< "\nKIND: " << stmt1->getKind() << std::endl;
    std::cout<< "\nKIND: " << stmt2->getKind() << std::endl;
    std::cout<< "\nKIND: " << stmt3->getKind() << std::endl;
    std::cout << "CODE: " << code << std::endl;
    code += stmt2->genProgramCode();
    std::cout << "CODE2: " << code << std::endl;
    code += stmt3->genProgramCode();

    return code;
}

genProgramCode(BlockStmt) {

    code += stmt1->genProgramCode();
    code += stmt2->genProgramCode();


    return code;
}

genProgramCode(AssignStmt) {
    return {};
}

genProgramCode(PrintStmt) {
    return {};
}

genProgramCode(IfStmt) {
    return {};
}

genProgramCode(WhileStmt) {
    return {};
}

genProgramCode(ForStmt) {
    return {};
}

genProgramCode(AddExpr) {
    code += expr1->genProgramCode();
    code += expr2->genProgramCode();
    code += "mov eax, " + expr1->place + "\n";
    code += "add eax, " + expr2->place + "\n";
    
    return code;
}

genProgramCode(SubExpr) {
    return code;
}

genProgramCode(MultExpr) {
    return {};
}


genProgramCode(EqualExpr) {
    return {};
}


genProgramCode(LessOrEqualExpr) {
    return {};
}

genProgramCode(LessExpr) {
    return {};
}

genProgramCode(GreaterOrEqualExpr) {
    return {};
}

genProgramCode(GreaterExpr) {
    return {};
}

genProgramCode(AndExpr) {
    return {};
}

genProgramCode(OrExpr) {
    return {};
}

genProgramCode(ModExpr) {
    return {};
}

genProgramCode(DivExpr) {
    return {};
}

genProgramCode(NotEqualExpr) {
    return code;
}

genProgramCode(NumExpr) {
    place = std::to_string(value);
    code = "";
    return code;
}

genProgramCode(IdentExpr) {

    bool found = false;
    for (auto &element : vec) {
        if (element.id == text) {
            place = element.placeStack;
            found = true;
            break;
        }
    }
    
    if (!found) {
        place = "[ebp + " + std::to_string(addOffset()) + "]";
        vec.push_back({text, place});
    }

    return code;
}


genProgramCode(DecVarStmt) {
    code += var1->genProgramCode();
    code += var2->genProgramCode();


    return code;
}

genProgramCode(IntDecl) {

    std::cout << "INT DECLARATION: " << std::endl;

    code += var1->genProgramCode();
    code += var2->genProgramCode();

    
    //std::cout << "INT DECLARATION: " << std::endl;
    return code;
}


genProgramCode(Program) {
    std::cout << "PROGRAM: " << std::endl;
    stmts->genProgramCode();
    code += stmts->code;
    code += "inicio:\n";

    std::cout << "\n" <<code << std::endl;

    // print the vector.
    for (auto &element : vec) {
        std::cout << "ID: " << element.id << " PLACE: " << element.placeStack << std::endl;
    }

    return code;
}


// Empty node.
genProgramCode(EmptyNode) {
    return code;
}


evalSemantic(AstNode) {
    return {};
}