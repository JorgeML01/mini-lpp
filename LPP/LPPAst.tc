%{ // cpp code
#include <iostream>
#include "LPPAst.hpp"

// Create a vector from SymbolVector.
SymbolVector vec;

%}

%decls %{ // hpp code
    #include <string>
    #include <cmath>
    #include <unordered_map>
    #include "SemError.hpp"
    #include <vector>

    using stdstring = std::string;

    struct structElements {
        stdstring id;
        int placeStack;
    };

    using SymbolVector = std::vector<structElements>;

%}

%option lang = "C++"


// NODOS.
%node AstNode %abstract %typedef = {
    %nocreate stdstring place;
    %nocreate stdstring code;
}

// STATEMENT NODES.
%node Stmt AstNode %abstract

%node Program AstNode = {
    AstNode* stmts;
}

%node BlockStmt Stmt = {
    AstNode* stmt1;
    AstNode* stmt2;
}

%node AssignStmt Stmt = {
    AstNode *var;
    AstNode *rvalue;
}

%node PrintStmt Stmt = {
    AstNode *expr;
}

%node IfStmt Stmt = {
    AstNode *cond;
    AstNode *stmt_t;
    AstNode *stmt_f;
}

%node WhileStmt Stmt = {
    AstNode *cond;
    AstNode *stmt;
}

%node ForStmt Stmt = {
    AstNode *init;
    AstNode *cond;
    AstNode *inc;
    AstNode *stmt;
}

%node BinaryExpr AstNode %abstract = {
    AstNode *expr1;
    AstNode *expr2;
}

%node AddExpr BinaryExpr
%node SubExpr BinaryExpr
%node MultExpr BinaryExpr
%node NotEqualExpr BinaryExpr
%node EqualExpr BinaryExpr
%node LessOrEqualExpr BinaryExpr
%node LessExpr BinaryExpr          
%node GreaterOrEqualExpr BinaryExpr 
%node GreaterExpr BinaryExpr
%node AndExpr BinaryExpr
%node OrExpr BinaryExpr
%node ModExpr BinaryExpr
%node DivExpr BinaryExpr

%node NumExpr AstNode = {
    int value;
}

%node IdentExpr AstNode = {
    stdstring text;
}


// OPERACIONES.
%operation %virtual int evalSemantic(AstNode *this)
%operation %virtual stdstring genProgramCode(AstNode *this) 

evalSemantic(Program) {
    return {};
}

evalSemantic(AddExpr) {
        
    return {};
}

evalSemantic(SubExpr) {
    return {};
}

evalSemantic(MultExpr) {
    return {};
}

evalSemantic(EqualExpr) {
    return {};
}

evalSemantic(NotEqualExpr) {
    return {};
}

evalSemantic(LessOrEqualExpr) {
    return {};
}

evalSemantic(LessExpr) {
    return {};
}

evalSemantic(GreaterOrEqualExpr) {
    return {};
}

evalSemantic(GreaterExpr) {
    return {};
}

evalSemantic(AndExpr) {
    return {};
}

evalSemantic(OrExpr) {
    return {};
}

evalSemantic(ModExpr) {
    return {};
}


evalSemantic(DivExpr) {
    return {};
}

evalSemantic(NumExpr) {
    return {};
}

evalSemantic(IdentExpr) {
    return {};
}

evalSemantic(AssignStmt) {
    return {};
}

evalSemantic(PrintStmt) {
    return {};
}

evalSemantic(IfStmt) {
    return {};
}

evalSemantic(WhileStmt) {
    return {};
}

evalSemantic(ForStmt) {
    return {};
}

evalSemantic(BlockStmt) {
    return {};
}

genProgramCode(Program) {
    return {};
}

genProgramCode(BlockStmt) {
    return {};
}

genProgramCode(AssignStmt) {
    return {};
}

genProgramCode(PrintStmt) {
    return {};
}

genProgramCode(IfStmt) {
    return {};
}

genProgramCode(WhileStmt) {
    return {};
}

genProgramCode(ForStmt) {
    return {};
}

genProgramCode(AddExpr) {
    code += expr1->genProgramCode();
    code += expr2->genProgramCode();
    code += "mov eax, " + expr1->place + "\n";
    code += "add eax, " + expr2->place + "\n";
    
    std::cout << "ADD EXPR: "  << code << std::endl;
    return {};
}

genProgramCode(SubExpr) {
    std::cout << "SUB EXPR" << std::endl;
    return {};
}

genProgramCode(MultExpr) {
    return {};
}


genProgramCode(EqualExpr) {
    return {};
}


genProgramCode(LessOrEqualExpr) {
    return {};
}

genProgramCode(LessExpr) {
    return {};
}

genProgramCode(GreaterOrEqualExpr) {
    return {};
}

genProgramCode(GreaterExpr) {
    return {};
}

genProgramCode(AndExpr) {
    return {};
}

genProgramCode(OrExpr) {
    return {};
}

genProgramCode(ModExpr) {
    return {};
}

genProgramCode(DivExpr) {
    return {};
}

genProgramCode(NumExpr) {
    place = std::to_string(value);
    code = "";
    return {};
}

genProgramCode(IdentExpr) {
    return {};
}

genProgramCode(NotEqualExpr) {
    return {};
}

